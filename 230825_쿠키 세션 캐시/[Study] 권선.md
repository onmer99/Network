### **클라이언트-서버 간의 상태 유지 및 데이터 저장**

쿠키와 세션은 웹에서 상태 정보를 유지하기 위해 사용되는 기술
HTTP는 상태를 유지하지 않는(stateless) 프로토콜
클라이언트와 서버 간의 통신에서 이전의 상호작용 정보를 기억X

#### **1. 쿠키(Cookie)**

- **정의**: 
  - 서버가 클라이언트의 웹 브라우저에 저장하도록 하는 작은 데이터의 조각입니다.

- **작동 원리**:
  - HTTP 헤더를 통해 전송되며, RFC 6265 표준에 따라 동작합니다.
  - 도메인과 경로를 기반으로, 해당 정보가 도메인에서 생성된 페이지로부터만 액세스 가능합니다.

<details>
<summary>RFC 6265는 웹 브라우징 환경에서 쿠키에 관한 사항을 규정하고 있는 표준 문서</summary>

1. **쿠키의 목적**: 
   - 세션 관리 (예: 로그인 상태 유지)
   - 개인화 (예: 사용자 설정, 테마 선택)
   - 트래킹 및 분석 (예: 사용자 행동 트래킹)

2. **쿠키의 설정 및 액세스**:
   - `Set-Cookie`와 `Cookie` HTTP 헤더를 통해 쿠키를 설정하고 액세스합니다.
   - `Set-Cookie` 헤더는 서버에서 클라이언트로 보내져, 클라이언트에게 쿠키를 저장하도록 지시합니다.
   - `Cookie` 헤더는 클라이언트가 서버에 요청을 보낼 때 쿠키 정보와 함께 전송됩니다.

3. **속성과 플래그**:
   - **Domain**: 쿠키가 관련된 도메인을 지정. 이 도메인에 대한 요청에서만 쿠키를 전송합니다.
   - **Path**: 쿠키가 관련된 경로를 지정. 이 경로에 대한 요청에서만 쿠키를 전송합니다.
   - **Expires/Max-Age**: 쿠키의 유효 기간 지정. 
   - **Secure**: 쿠키가 HTTPS 연결을 통해서만 전송되도록 합니다.
   - **HttpOnly**: 쿠키가 자바스크립트에서 액세스되는 것을 방지합니다.

4. **제한 사항**:
   - 특정 도메인 및 경로에 대한 쿠키 수의 제한
   - 각 쿠키의 크기와 전체 쿠키의 최대 크기 제한
</details>


- **보안 문제**:
  - 쿠키의 내용은 중요하지 않거나, 암호화되어야 합니다. 
  - Third-party 쿠키(써드파티 쿠키)로 인한 개인정보 유출 우려가 있습니다.

<details>
<summary>Third-party 쿠키</summary>
광고 트래킹: 다양한 웹사이트에서 사용자의 행동을 추적하여 타겟팅 광고를 제공하는데 사용됩니다. 예를 들어, 사용자가 한 웹사이트에서 특정 제품을 보았다면, 다른 웹사이트를 방문할 때 해당 제품과 관련된 광고를 볼 수 있습니다.  
사이트 간 로그인: 일부 소셜 미디어 사이트는 다른 웹사이트에서도 로그인 상태를 유지할 수 있게 해주는데, 이를 위해 Third-party 쿠키를 사용합니다.  
콘텐츠 임베딩: 웹사이트에 유튜브 비디오나 페이스북 좋아요 버튼 같은 외부 콘텐츠를 임베드 할 때, 해당 서비스 제공자가 쿠키를 설정하여 사용자의 활동을 추적할 수 있습니다.  
프라이버시 우려: Third-party 쿠키는 사용자의 웹 브라우징 활동을 다양한 사이트에서 추적할 수 있어, 개인 정보 보호와 프라이버시에 관한 우려가 있습니다.  
브라우저의 차단: 위의 프라이버시 우려로 인해, 많은 웹 브라우저들이 Third-party 쿠키를 기본적으로 차단하거나 사용자에게 선택권을 부여하고 있습니다.  
도메인 간 우회: 일부 광고회사나 서비스 제공자들은 Third-party 쿠키 차단을 우회하기 위한 다양한 방법을 사용하기도 합니다.
</details>

- **활용**: 
  - 로그인 상태, 사용자 환경 설정, 장바구니 정보 등 

#### **2. 세션(Session)**

- **정의**:
  - 클라이언트와 서버 간의 일시적인 상호 작용을 위한 저장 공간. 

- **작동 원리**:
  - 서버는 클라이언트에게 유일한 세션 ID를 제공하며, 이 ID는 쿠키, URL, 또는 클라이언트 페이지 내에 포함될 수 있습니다.
  - 세션 데이터는 서버에 저장되므로, 사용자가 로그아웃하거나 세션 시간이 만료되면 데이터가 삭제됩니다.

<details>
<summary>세션 ID</summary>
인증 정보: 사용자가 로그인한 후, 그들의 인증 상태와 관련된 정보(예: 사용자 ID, 로그인 상태 등).  
사용자 환경설정: 사용자가 웹 사이트 내에서 선택한 환경설정(예: 언어, 테마, 레이아웃 설정 등).  
임시 데이터: 장바구니에 추가한 항목, 설문조사 응답, 퀴즈의 중간 답변 등 사용자가 완료하지 않은 작업과 관련된 일시적인 정보.  
페이지 내 이동 정보: 사용자가 방문한 페이지, 검색어, 클릭한 광고 등의 이동 경로 정보.  
플래시 메시지: 일회성으로 사용자에게 표시되는 메시지. 예를 들어, 사용자가 어떤 작업을 성공적으로 수행하면 "저장되었습니다."와 같은 메시지를 보여줄 수 있습니다.  
대화 상태 정보: 실시간 채팅 기능과 같은 멀티스텝 대화의 중간 상태를 저장.
</details>

- **보안**:
  - 세션 자체는 비교적 안전하지만, 세션 고정화(Session Fixation)나 세션 하이재킹과 같은 공격에 취약할 수 있습니다.

<details>
<summary>세션 고정화(Session Fixation)</summary>
세션 ID 획득: 공격자는 웹 사이트에 방문하여 세션 ID를 획득합니다.  
세션 ID 전달: 공격자는 다양한 방법(링크, 이미지, 이메일 등)을 통해 특정 사용자에게 고정된 세션 ID를 전달합니다.  
사용자의 로그인: 특정 사용자는 공격자가 제공한 링크나 웹 페이지를 통해 웹 사이트에 접속하고, 그 세션 ID로 로그인을 시도합니다.  
세션 탈취: 사용자가 공격자가 제공한 세션 ID로 로그인하게 되면, 공격자는 이미 그 세션 ID를 알고 있기 때문에 사용자의 세션을 탈취하거나 조작할 수 있습니다.  
로그인 성공 후 세션 재발급: 사용자가 로그인할 때마다 새로운 세션 ID를 발급하여, 기존의 세션 ID를 무효화하는 것이 중요합니다. 이렇게 하면 공격자가 미리 획득한 세션 ID를 사용하여 공격하는 것을 방지할 수 있습니다.  
세션 유효시간 설정: 세션에 짧은 유효 시간을 설정하여, 오랜 시간 동안 사용되지 않는 세션은 자동으로 만료되게 합니다.  
세션 ID의 안전한 전송: 세션 ID는 HTTPS와 같은 안전한 프로토콜을 사용하여 전송되어야 합니다. 또한, URL의 일부로 세션 ID를 전달하는 것을 피해야 합니다.  
세션 ID의 복잡성: 세션 ID는 충분히 길고 복잡해야 하며, 예측하기 어려운 방식으로 생성되어야 합니다.

SSL/TLS와 같은 보안 프로토콜을 사용하여 데이터를 안전하게 전송
</details>

- **활용**: 
  - 사용자 로그인 정보, 임시 사용자 설정, 특정 사용자에 대한 서버의 임시 데이터 저장

#### **3. 캐시(Cache)**

- **정의**:
  - 최근 또는 자주 사용되는 데이터를 빠르게 검색하고 접근하기 위해 임시로 저장하는 메커니즘.

- **작동 원리**:
  - HTTP 헤더(Etag, Cache-Control, Last-Modified 등)를 활용하여 클라이언트와 서버 간의 데이터 동기화를 관리합니다.
  - 데이터가 변경되지 않았을 경우, 캐시된 데이터를 반환하여 성능 향상과 서버 부하 감소 효과를 얻습니다.

<details>
<summary>HTTP 헤더</summary>
Cache-Control
이 헤더는 웹 브라우저와 캐시에 자원을 어떻게 캐싱해야 하는지에 대한 지시를 제공합니다.
예: Cache-Control: no-store (자원을 캐시에 저장하면 안 된다), Cache-Control: max-age=3600 (자원을 3600초 동안 캐시에 저장하고 사용할 수 있다).
Expires
특정 날짜/시간 후에 캐시된 자원이 만료될 것임을 나타냅니다.
예: Expires: Wed, 21 Oct 2020 07:28:00 GMT
ETag (Entity Tag)
특정 버전의 자원을 나타내는 문자열입니다. 서버와 클라이언트 간에 자원의 버전을 확인하여 변경 여부를 판단하는 데 사용됩니다.
Last-Modified
자원이 마지막으로 수정된 날짜/시간을 나타냅니다.
If-None-Match
이전 요청에서 받은 ETag 값과 일치하는지 검사하는 데 사용됩니다. 값이 일치하면, 서버는 변경되지 않았음을 알리는 304 Not Modified 상태 코드를 반환할 수 있습니다.
If-Modified-Since
지정된 날짜 이후에 자원이 수정되었는지 확인하는 데 사용됩니다. 수정되지 않았으면 서버는 304 Not Modified 상태 코드를 반환할 수 있습니다.
Vary
결정적인 캐싱 동작을 위해 어떤 요청 헤더를 기반으로 캐시 응답을 달리할 것인지 지정합니다.
예: Vary: Accept-Encoding은 같은 URL의 요청이지만 다른 'Accept-Encoding' 헤더 값을 가진 경우 다른 버전의 캐시를 제공해야 함을 나타냅니다.
Pragma
HTTP/1.0과의 호환성을 위한 헤더로, Cache-Control: no-cache와 같은 역할을 합니다. 하지만 현대의 HTTP 버전에서는 Cache-Control을 사용하는 것이 권장됩니다.
</details>

- **보안**:
  - 캐시 중간자(Man-in-the-Middle) 공격에 취약할 수 있으므로, 중요한 정보는 캐시에서 제외되어야 합니다.

<details>
<summary>중간자(Man-in-the-Middle, MitM) 공격</summary>
공격자가 통신 중인 두 당사자 사이에 위치하여 정보를 도청하거나 수정하는 공격 방식입니다. 캐시 중간자 공격은 이러한 MitM 공격의 한 유형으로, 웹 캐시에 직접 영향을 주는 특별한 방법으로 진행됩니다.

공격 예  
Web Cache Poisoning: 공격자는 서버에 특정한 요청을 보내어 그 응답이 캐시에 저장되게 합니다. 이후 다른 사용자가 같은 요청을 하면, 오염된 캐시 응답이 전달됩니다.  
Cache Deception: 공격자는 캐시되지 않아야 할 정보가 캐시에 저장되도록 서버에 요청을 보냅니다. 캐시에 민감한 정보가 저장되면, 그 정보에 액세스하려는 다른 공격 방법을 사용할 수 있습니다.  

방어 방법  
HTTP 헤더 사용: 캐싱 동작을 제어하는 HTTP 헤더(예: Cache-Control: no-store)를 사용하여 민감한 정보가 캐시되지 않도록 합니다.  
캐시 세분화: 다양한 사용자 에이전트나 쿠키 값에 따라 다른 캐시 버전을 저장하여, 공격자의 요청이 일반 사용자의 캐시에 영향을 주지 않게 합니다.  
웹 캐시 구성 검토: 웹 캐시 설정을 정기적으로 검토하고 최적화하여, 잠재적 취약점을 미리 차단합니다.  
콘텐츠 보안 정책 (CSP): CSP를 사용하여 특정 콘텐츠(스크립트, 스타일 등)의 로딩 소스를 제한하거나 차단합니다.  
</details>

- **활용**: 
  - 웹 페이지 로딩 속도 향상, 네트워크 대역폭 절약, 서버 부하 감소

<details>
<summary>브라우저 캐시 (Client-Side Cache)</summary>
목적: 웹사이트를 방문할 때, 이전에 다운로드한 자원들 (예: 이미지, 스타일시트, 자바스크립트 파일 등)을 로컬에 저장함으로써, 동일한 자원을 다시 다운로드하는 시간과 대역폭을 절약합니다. 이를 통해 페이지 로딩 속도를 빠르게 합니다.  
  
장점:  
네트워크 지연 시간을 크게 줄일 수 있습니다.  
서버에 대한 요청이 감소하므로, 서버의 부하도 줄어듭니다.  
단점:  
브라우저 캐시는 사용자별로 독립적이므로, 각 사용자가 처음 웹사이트를 방문할 때는 초기 다운로드 시간이 필요합니다.  
오래된 캐시 데이터로 인해 최신의 웹 페이지 내용을 보지 못할 수도 있습니다.  
저장 위치: 사용자의 컴퓨터의 하드 드라이브나 메모리에 저장됩니다.  
</details>
