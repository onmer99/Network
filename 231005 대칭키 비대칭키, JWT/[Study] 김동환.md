- 대칭키
    - 데이터 암호화, 복호화 과정에서 동일한 키를 사용하는 기술
    - 속도 : 빠름, 따라서 대용량 데이터 처리에 유리
    - 키를 교환해야하고, 안전하게 교환할 수 있는 방식이 요구된다, 사람이 증가할수록 키 관리가 어려워진다
    - 기능 : 기밀성
    - 대표 알고리즘 : DES, AES, 3DES, SEED, ARIA 등
- 비대칭키(공개키)
    - 데이터 암호화, 복호화 과정에서 서로 다른 키를 사용하는 기술
    - 수신자는 공개키와 개인키를 가지고 있다
    - 방식
        - 암호모드 : 송신자는 수신자의 공개키로 암호화를 하고, 수신자는 수신자가 고유하게 가지고 있는 개인키로 복호화를 한다
        - 인증모드 : 송신자는 자기 고유의 개인키로 암호화를 하고, 수신자는 송신자의 공개키르 복호화를 진행한다
    - 따라서 키를 교환할 필요가 없어서, 키가 탈취될 위험이 없다
    - 속도 : 느림
    - 기능 : 기밀성, 무결성, 인증, 부인방지
    - 대표 알고리즘 : RSA, DSA, ECDSA 등
    
- JWT(JSON Web Token)
: 웹에서 데이터를 안전하게 전달하기 위한 "인증 및 권한"부여 메커니즘이다.  주로 인증을 위해 사용된다.
JWT는 Base64로 인코딩된 JSON 객체이며 토큰 형태로 표현된다.
Header, Payload, Signature로 이루어져 있으며, 각각은 한 문장에서 "."으로 구분되어있다
(즉, JWT = 헤더.페이로드.서명)
    - Header : 헤더에는 다음의 두 정보가 포함된다
        
        ```json
        {
        	"typ" : "토큰의 유형(일반적으로 JWT)",
        	"alg" : "암호화 알고리즘(RSA, HMAC SHA256 등)이 포함됨"
        }
        ```
        
    - Payload : 토큰에 포함되는 Claim 정보가 포함된다. Claim은 서버와 클라이언트 간에 공유되는 정보다
        - Registered Claim : 토큰 사용을 표준화 하기 위해서, 이미 정해진 종류의 데이터
            
            ```json
            {
            	"iss" : "issuer, 토큰 발급자를 의미",
            	"sub" : "subject, 토큰 제목을 의미",
                "aud" : "audience, 토큰 대상자를 의미",
                "iat" : "issuedAt, 토큰 발급 시간을 의미",
                "exp" : "expiration, 토큰 만료 시간을 의미",
                "nbf" : "not before, 토큰활성날짜를 의미. 이 날이 지나야 토큰이 활성화된다",
            	"jti" : "jwt id, 토큰 식별자를 의미. 줒ㅇ복 방지를 위해 사용하며, 일회용 토큰(like AccessToken)등에 사용된다"
            }
            ```
            
        - Public Claim : 사용자 정의 클레임으로, 사용자 정보나 추가 데이터를 포함한다. 이 정보는 공개용 정보이고, 충돌 방지를 위해 URI 포맷을 이용한다
            
            ```json
            { 
            	"https://mangkyu.tistory.com": "true"
            }
            ```
            
        - Private Claim : 사용자 정의 클레임으로, 서버와 클라이언트 사이에 임의로 지정한 정보를 저장한다. key-value 형태로 사용한다.
    - Signature : 서명은, 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 코드이다
        - 헤더와 페이로드를 서명을 통해 각각 Base64 Url로 인코딩한다.
        - 각각은 시크릿키를 이용해 헤더에서 정의한 알고리즘으로 해싱하고, 이 값을 다시 Base64 Url로 인코딩하여 생성한다.
    
    - 주의사항
        - Payload 자체는 암호화 된 것이 아니라, Base64Url로 인코딩 된 것이다. 따라서 탈취하면 손쉽게 디코딩하여 정보를 볼 수 있다
        - Stateless하기 때문에 임의로 삭제하는것이 불가능하다. 따라서 꼭 토큰 만료시간을 넣어줘야한다.
        - 토큰은 클라이언트측에서 관리해야 하므로, 토큰을 저장해야한다
