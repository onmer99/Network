- JWT 토큰에 대해 설명해주세요.
    
    JSON Web Token: 두 개체 사이에서 정보를 안전하게 전송하기 위한 컴팩트하고 독립적인 방식으로 정보를 나타내는 JSON 객체
    
    - JSON 객체
        
        JSON 파일이 아님
        
        JSON 객체 형식을 사용하여 데이터
        
        `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`
        
        - 헤더 (Header)
            
            ```json
            {
            "alg": "HS256",
            "typ": "JWT"
            }
            ```
            
        - 페이로드 (Payload)
            
            ```json
            {
              "sub": "1234567890",
              "name": "John Doe",
              "iat": 1516239022
            }
            ```
            
        - 서명 (Signature)
            
            토큰의 무결성을 보장하고 발신자의 인증을 제공하는 데 중요한 역할
            
            암호화 알고리즘의 출력 결과로, 보통 바이너리 형식의 데이터
            
            - 바이너리 형식의 데이터
                
                데이터가 2진법 (0과 1)으로 표현된 형태를 의미
                
                ### **바이너리 데이터의 특징:**
                
                1. **2진법으로 표현**: 바이너리 데이터는 0과 1로만 구성됩니다. 이러한 0과 1의 조합은 '비트'라고 불리며, 8개의 비트를 '바이트'라고 합니다.
                2. **범용성**: 텍스트, 이미지, 오디오, 비디오 등 모든 유형의 데이터는 바이너리 형식으로 표현될 수 있습니다.
                3. **인코딩/디코딩**: 바이너리 데이터는 특정 인코딩 방식에 따라 읽고 쓸 수 있습니다. 예를 들어, 텍스트 데이터는 UTF-8, UTF-16과 같은 문자 인코딩을 사용하여 바이너리로 변환될 수 있습니다.
                4. **데이터의 원시 형태**: 바이너리는 데이터의 가장 기본적이고 원시적인 형태로 볼 수 있습니다.
                
                ### **바이너리 데이터와 텍스트 데이터:**
                
                데이터는 크게 바이너리 데이터와 텍스트 데이터로 분류될 수 있습니다.
                
                - **텍스트 데이터**: 인간이 읽을 수 있는 문자들로 구성된 데이터입니다. 예를 들어, **`.txt`** 파일이나 HTML 코드, JSON 문자열 등이 여기에 해당합니다.
                - **바이너리 데이터**: 인간이 직접 읽을 수 없는 데이터 형식입니다. 이미지 파일 (**`.jpg`**, **`.png`**), 오디오 파일, 실행 가능한 프로그램 파일 등이 여기에 해당합니다.
                
                물론, 이러한 바이너리 데이터도 적절한 프로그램이나 도구를 사용하면 읽거나 표현할 수 있습니다. 예를 들어, **`.jpg`** 이미지 파일은 바이너리 형식의 데이터로 저장되지만, 이미지 뷰어 프로그램을 사용하면 해당 이미지를 시각적으로 확인할 수 있습니다.
                
                ### **바이너리 데이터의 활용:**
                
                바이너리 형식의 데이터는 다양한 응용 분야에서 활용됩니다:
                
                1. **파일 저장**: 대부분의 파일 형식 (텍스트, 이미지, 오디오, 비디오 등)은 바이너리 형식으로 저장됩니다.
                2. **데이터 전송**: 네트워크를 통해 데이터를 전송할 때도 바이너리 형식을 사용합니다.
                3. **암호화 및 해시**: 보안 관련 작업에서 생성된 암호화된 데이터나 해시 값은 바이너리 형식으로 표현됩니다.
        
        헤더와 페이로드는 Base64Url로 인코딩된 JSON 문자열
        
        서명 부분은 JSON 형식이 아님
        
    
    - **헤더 (Header)**: 토큰의 유형 (보통 "JWT"로 설정)과 사용되는 서명 알고리즘 (예: HMAC SHA256 또는 RSA)을 정의합니다.
        1. **alg**: 이는 사용된 서명 알고리즘을 나타냅니다. 예를 들어, **`"HS256"`**은 HMAC을 사용한 SHA-256 알고리즘을 의미합니다. 다른 알고리즘으로는 **`"RS256"`** (RSA를 사용한 SHA-256) 등이 있습니다.
        2. **typ**: 이는 토큰의 타입을 나타냅니다. JWT의 경우, 이 값은 보통 **`"JWT"`**로 설정됩니다.
    - **페이로드 (Payload)**: 이 부분에는 토큰에 포함될 클레임(정보)이 포함됩니다. 클레임은 토큰의 주체와 관련된 정보 조각입니다. 클레임은 세 가지 유형으로 나뉩니다: 등록된 (registered), 공개 (public), 및 비공개 (private) 클레임.
        1. **등록된 (Registered) 클레임**: 이러한 클레임은 JWT 명세에서 사전에 정의된 클레임입니다. 이들 클레임의 이름은 짧은 3글자의 이름으로 구성되며, 선택적으로 사용될 수 있습니다. 예로는:
            - **`iss`**: 토큰의 발행자
            - **`exp`**: 토큰의 만료 시간
            - **`sub`**: 주제 (토큰이 어떤 것에 대한 것인지)
            - **`aud`**: 토큰의 대상자
            - 등등...
        2. **공개 (Public) 클레임**: 이러한 클레임은 임의로 정의될 수 있지만, 충돌을 피하기 위해 JWT 명세에서 정의된 이름을 사용하는 것이 좋습니다.
            1. JWT 사용자 커뮤니티에 의해 사전에 정의되고, 공개적으로 사용되는 클레임
            2. JWT 사용자 간의 충돌을 방지하기 위해 IANA "JSON Web Token Claims" 레지스트리에 등록될 수 있음
            3. 일정한 네임스페이스나 URL 형태로 지정
        3. **비공개 (Private) 클레임**: 이러한 클레임은 서버와 클라이언트 간에 합의된 이름을 사용하여 생성됩니다. 일반적으로 사용자의 정보나 권한 등을 나타내는 데 사용됩니다.
            
            비공개 클레임은 서버와 클라이언트 간의 특정 요구 사항에 따라 결정되며, 이러한 클레임의 정의와 사용 방법은 일반적으로 서버에 의해 제공되는 문서나 가이드를 통해 알려짐. 클라이언트는 이러한 정보를 기반으로 JWT의 클레임을 올바르게 사용할 수 있음.
            
    - **서명 (Signature)**: 이 부분은 헤더와 페이로드를 합친 후 주어진 시크릿으로 서명하는 것으로 구성됩니다. 서명은 토큰의 무결성을 검증하고, 발신자의 인증을 보장하는 데 사용됩니다.
        
        토큰의 무결성을 보장하는 데 사용
        
        헤더와 페이로드의 내용을 기반으로 생성되며, 토큰이 전송된 후에 변경되지 않았음을 확인하는 데 사용
        
        1. **서명 생성**:
            1. 헤더와 페이로드를 Base64Url 인코딩합니다.
            2. 인코딩된 헤더와 페이로드를 점(**`.`**)으로 연결합니다.
            3. 이 연결된 문자열을 헤더에 지정된 암호화 알고리즘과 함께 비밀 키(또는 공개/개인 키 쌍의 경우 개인 키)를 사용하여 서명합니다.
                - 비밀키(secret key)
                    
                    문자 형태의 암호나 바이트 배열로 되어 있는 구체적인 값
                    
                    JWT의 서명 생성 및 검증에 사용되는 알고리즘에 필요한 입력값 중 하나
                    
                - 알고리즘(algorithm)
                    
                    데이터를 처리하는 일련의 지침 또는 규칙의 집합
                    
                    - **암호화 알고리즘**
                        
                        이 알고리즘은 텍스트나 데이터를 다른 형태로 변환하여 원본 데이터의 내용을 숨깁니다. 암호화된 데이터는 해당 알고리즘의 "복호화" 과정을 통해 원본 데이터로 변환할 수 있습니다. 대표적인 예로는 AES, RSA 등이 있습니다.
                        
                    - **해시 알고리즘**
                        
                        이 알고리즘은 데이터를 고정된 길이의 문자열 (해시 값)로 변환합니다. 이 변환 과정은 일방향적이므로, 해시 값에서 원본 데이터로 돌아가는 것은 불가능합니다. 대표적인 예로는 SHA-256, MD5 등이 있습니다.
                        
                    - **디지털 서명 알고리즘**
                        
                        이 알고리즘은 데이터의 무결성과 발신자의 인증을 보장하기 위해 사용됩니다. 데이터에 대한 서명을 생성하고, 해당 서명을 검증하는 데 사용됩니다. 대표적인 예로는 HMAC, RSA 서명 등이 있습니다.
                        
                        - **개인 키 (Private Key)**
                            - 개인 키는 개인적으로 보관되어야 하며, 타인에게 노출되면 안 됩니다.
                            - 개인 키는 데이터를 암호화하거나 디지털 서명을 생성하는 데 사용될 수 있습니다.
                            - 예를 들어, 디지털 서명을 생성할 때는 개인 키를 사용하여 서명을 만듭니다.
                        - **공개 키 (Public Key)**
                            - 공개 키는 일반적으로 공개될 수 있습니다. 예를 들어, 디지털 인증서에 포함되어 배포되기도 합니다.
                            - 공개 키는 데이터를 복호화하거나 디지털 서명을 검증하는 데 사용됩니다.
                            - 예를 들어, 디지털 서명을 검증할 때는 공개 키를 사용하여 서명이 올바른지 확인합니다.
                        - 개인 키로 암호화된 데이터는 해당 공개 키로만 복호화될 수 있습니다.
                        - 공개 키로 암호화된 데이터는 해당 개인 키로만 복호화될 수 있습니다.
                        - 개인 키로 생성된 디지털 서명은 해당 공개 키로만 검증될 수 있습니다.
            4. 결과적으로 생성된 서명은 Base64Url로 인코딩되어 JWT의 마지막 부분으로 추가됩니다.
        2. **서명 검증**:
            1. 수신한 JWT에서 인코딩된 헤더와 페이로드를 분리합니다.
            2. 동일한 방식으로 인코딩된 헤더와 페이로드를 점(**`.`**)으로 연결합니다.
            3. 연결된 문자열에 대해 헤더에서 지정된 암호화 알고리즘과 함께 비밀 키(또는 공개 키)를 사용하여 서명을 다시 계산합니다.
            4. 계산된 서명이 수신한 JWT의 서명 부분과 일치하면, 토큰이 변경되지 않았음이 확인되며, 그렇지 않으면 토큰이 손상되었거나 위조되었다고 판단됩니다.
        
        서버 → 클라이언트 → 서버(검증)
        
    
    ### **JWT의 작동 방식:**
    
    1. **인증**: 사용자가 시스템에 로그인할 때 (예: 아이디와 비밀번호 사용), 서버는 사용자의 자격 증명을 검증합니다.
    2. 검증 후, 서버는 JWT를 생성하고 사용자에게 반환합니다.
    3. 사용자는 이후의 모든 요청에 JWT를 첨부하게 되며, 서버는 이 토큰을 사용하여 사용자를 식별하고 인증합니다.
    4. JWT는 일정 시간 후에 만료될 수 있으므로, 사용자는 일정 시간마다 새로운 토큰을 받아야 할 수도 있습니다.
    
    ### **JWT의 장점:**
    
    1. **스케일링**: JWT는 상태를 저장하지 않기 때문에 서버와 클라이언트 간의 인증에 아주 적합합니다. 각 요청에 토큰이 포함되어 있기 때문에 별도의 세션 저장소가 필요하지 않습니다.
    2. **모바일 앱**: JWT는 모바일 앱과의 인증에도 적합합니다.
        - **Shared Preferences (안드로이드) / UserDefaults (iOS)**:
            - 장점: 사용하기 쉽습니다.
            - 단점: 보안성이 높지 않습니다. 루팅 또는 재일보험된 장치에서는 데이터가 노출될 위험이 있습니다.
        - **Keychain (iOS) / Keystore (안드로이드)**:
            - 장점: 암호화된 저장소에서 키를 안전하게 저장합니다. 루팅 또는 재일보험된 장치에서도 데이터 보호 기능이 강화되어 있습니다.
            - 단점: 사용이 좀 더 복잡하며, 모든 데이터에 대해 사용하기에는 오버킬일 수 있습니다.
        - **SQLite 데이터베이스**:
            - 장점: 데이터베이스 내에서 JWT와 관련된 다른 데이터와 함께 저장할 수 있습니다.
            - 단점: 루팅 또는 재일보험된 장치에서는 데이터가 노출될 위험이 있습니다. 보안 강화를 위해 추가적인 암호화 레이어를 적용할 수 있습니다.
        - **인메모리 저장**:
            - 장점: JWT는 애플리케이션의 메모리에만 저장되므로, 애플리케이션이 종료되면 JWT도 사라집니다.
            - 단점: 애플리케이션을 종료하거나 장치를 재부팅할 때마다 사용자가 다시 로그인해야 합니다.
        - **Secure Enclave (특정 iOS 장치에서 사용 가능)**:
            - 장점: 매우 높은 수준의 보안을 제공합니다.
            - 단점: 모든 iOS 장치에서 사용 가능한 것은 아닙니다.
    3. **분산 시스템 인증**: JWT는 다양한 도메인 간의 인증에 유용합니다.
    
    ### **JWT의 단점:**
    
    1. **토큰 크기**: JWT는 많은 정보를 포함할 수 있기 때문에, 토큰의 크기가 커질 수 있습니다. 이로 인해 트래픽에 영향을 줄 수 있습니다.
    2. **보안**: JWT는 만료 시간이 있지만, 토큰이 탈취되면 그 사이의 시간 동안 악용될 수 있습니다. 따라서 HTTPS와 같은 안전한 채널을 통해 토큰을 전송하는 것이 중요합니다.
        - 만료 시간
            
            exp(expiry) 라는 클레임 이름으로 페이로드에 포함
            
            NumericDate 형식으로, 1970년 1월 1일 00:00:00 UTC 이후의 초 단위로 표현
            
            유닉스 타임스탬프 (또는 유닉스 에포크) 형식과 동일
            

- 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.
    
    ### **. 대칭키 암호화 (Symmetric-key Encryption):**
    
    - **특징**: 암호화와 복호화에 동일한 키를 사용합니다.
    - **예시**: DES, 3DES, AES, RC4 등
    - **장점**:
        - 빠른 처리 속도: 대칭키 암호화는 비대칭키 암호화에 비해 계산적으로 훨씬 간단하므로 빠릅니다.
        - 간단한 구조: 한 개의 키만 관리하면 됩니다.
    - **단점**:
        - 키 교환 문제: 키를 안전하게 전달하는 것이 어려워, 키 관리 및 배포에 어려움이 있습니다.
        - 만약 키가 탈취된다면 암호화된 모든 데이터가 위험에 처하게 됩니다.
    
    ### **2. 비대칭키 암호화 (Asymmetric-key Encryption):**
    
    - **특징**: 암호화와 복호화에 다른 키 (공개키와 비밀키)를 사용합니다.
    - **예시**: RSA, DSA, ECC, ElGamal 등
    - **장점**:
        - 키 교환 문제 해결: 공개키는 누구나 접근할 수 있으며, 비밀키는 소유자만이 가지고 있습니다. 따라서 키 교환 문제 없이 안전하게 데이터를 전송할 수 있습니다.
        - 디지털 서명 및 인증에 활용될 수 있습니다.
    - **단점**:
        - 처리 속도: 대칭키 암호화보다 계산이 복잡하므로 처리 속도가 느립니다.
        - 키 길이: 안전한 암호화를 위해 긴 키 길이가 필요합니다.
